[{"id":"652ddf232f9ac683","type":"inject","z":"b956abd7fd2a06d1","d":true,"name":"ECHONET Lite Get request","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"10,81,00,01,05,FF,01,0E,F0,01,62,01,D6,00","payloadType":"str","x":260,"y":1760,"wires":[["6c1f3e6a6150c246"]]},{"id":"68840b042ec13467","type":"udp out","z":"b956abd7fd2a06d1","d":true,"name":"","addr":"224.0.23.0","iface":"","port":"3610","ipv":"udp4","outport":"","base64":false,"multicast":"broad","x":820,"y":1760,"wires":[]},{"id":"6c1f3e6a6150c246","type":"function","z":"b956abd7fd2a06d1","d":true,"name":"Convert Hex List to Buffer ","func":"// Input: msg.payload = \"10,81,00,01,05,FF,01,0E,F0,01,62,01,D6,00\"\nlet hexList = msg.payload.split(',');\nlet byteArray = hexList.map(h => parseInt(h.trim(), 16));\nmsg.payload = Buffer.from(byteArray);\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":550,"y":1760,"wires":[["68840b042ec13467"]]},{"id":"a908a737f5d752ad","type":"inject","z":"b956abd7fd2a06d1","name":"Request Battery Data","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"300","crontab":"","once":true,"onceDelay":0.1,"topic":"request_all","payload":"","payloadType":"date","x":200,"y":700,"wires":[["c1c73a0e41f01691","9ae2bdd297c157cc","ec0dc701997716e0"]]},{"id":"c1c73a0e41f01691","type":"function","z":"b956abd7fd2a06d1","name":"Prepare Battery Request","func":"// Function to generate a simple, incrementing Transaction ID\n// In a real system, you might want something more robust for uniqueness\nlet currentTid = 0;\n\nfunction generateTid() {\n    currentTid = (currentTid + 1) % 0x10000; // TIDs are 2 bytes (0x0000 to 0xFFFF)\n    return currentTid;\n}\n\n// Get the raw payload\n// const payload = msg.payload; // Not needed here as we are creating the payload\n\nconst controllerSEOJ = Buffer.from('05FF01', 'hex');\nconst batteryDEOJ = Buffer.from('027D1F', 'hex'); // OMRON Battery Object ID\nconst service = 0x62; // GET service (0x62)\n\nconst properties = [\n    { epc: 0x80, pdc: 0x00 }, // Operation status\n    { epc: 0xE4, pdc: 0x00 }, // Measured Remaining Capacity 1 (%)\n    { epc: 0x88, pdc: 0x00 }, // Fault Status\n    { epc: 0xC1, pdc: 0x00 }, // Capacity for grid connection\n    { epc: 0xC2, pdc: 0x00 }, // Rated power for grid connection\n    { epc: 0xDA, pdc: 0x00 }, // Remaining stored electricity amount 2\n    { epc: 0x42, pdc: 0x00 }, // Instantaneous Electric Power (test this!)\n    { epc: 0x89, pdc: 0x00 }  // Additional discharge-related EPC (optional) //,\n    // { epc: 0xCF, pdc: 0x00 } // Vendor-specific battery mode/status\n];\n\n\nlet opc = properties.length;\nlet tid = generateTid(); // Generate a new TID for this request\n\nlet bufferParts = [\n    Buffer.from('1081', 'hex'),         // EHD (ECHONET Lite Header)\n    Buffer.from(tid.toString(16).padStart(4, '0'), 'hex'), // TID (Transaction ID)\n    controllerSEOJ,                     // SEOJ (Source ECHONET Object)\n    batteryDEOJ,                        // DEOJ (Destination ECHONET Object)\n    Buffer.from([service]),             // ESV (ECHONET Service)\n    Buffer.from([opc])                  // OPC (Number of properties)\n];\n\nproperties.forEach(prop => {\n    bufferParts.push(Buffer.from([prop.epc, prop.pdc])); // EPC and PDC for each property\n});\n\nmsg.payload = Buffer.concat(bufferParts);\nmsg.ip = \"192.168.86.181\"; // Target IP for Battery\nmsg.port = 3610;            // ECHONET Lite port\nmsg.topic = 'omron_battery_data_request_new_epcs'; // Informative topic\n\n// Store the TID in flow context or global context associated with the IP\n// This assumes a 'flow' context named 'outstandingRequests'\n// You might want to use global context if multiple flows need to access it.\nconst outstandingRequests = flow.get('outstandingRequests') || {};\nif (!outstandingRequests[msg.ip]) {\n    outstandingRequests[msg.ip] = new Set(); // Use a Set for efficient TID checking\n}\noutstandingRequests[msg.ip].add(tid); // Store the TID (decimal for easier comparison)\nflow.set('outstandingRequests', outstandingRequests);\n\nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":450,"y":700,"wires":[["6175e1140645607b"]]},{"id":"6175e1140645607b","type":"udp out","z":"b956abd7fd2a06d1","name":"UDP Out (Battery)","addr":"192.168.86.181","iface":"","port":"3610","ipv":"udp4","outport":"","base64":false,"multicast":"false","x":710,"y":700,"wires":[]},{"id":"e79e612dd17e1329","type":"udp in","z":"b956abd7fd2a06d1","name":"UDP In (ECHONET Lite)","iface":"","port":"3610","ipv":"udp4","multicast":"true","group":"224.0.23.0","datatype":"buffer","x":150,"y":940,"wires":[["5ab1126e55665fe4","c0b11e25e985b46d"]]},{"id":"c0b11e25e985b46d","type":"function","z":"b956abd7fd2a06d1","name":"Parse ECHONET Lite Response","func":"// Function to convert a hex string (e.g., \"0x01\") to a decimal number.\nfunction hexToDec(hex) {\n    if (typeof hex !== 'string' || !hex.startsWith('0x')) {\n        return null; // Or throw an error, depending on desired error handling\n    }\n    return parseInt(hex.substring(2), 16);\n}\n\n// Function to parse the instance list (0xD6)\nfunction parseInstanceList(edt) {\n    if (!edt || typeof edt !== 'string' || !edt.startsWith('0x')) {\n        return [];\n    }\n    const hexString = edt.substring(2); // Remove \"0x\"\n    const eojs = [];\n    // Each EOJ is 3 bytes (6 hex characters)\n    for (let i = 0; i < hexString.length; i += 6) {\n        if (i + 6 <= hexString.length) {\n            eojs.push('0x' + hexString.substring(i, i + 6).toUpperCase());\n        }\n    }\n    return eojs;\n}\n\n// Get the raw payload\nconst payload = msg.payload;\n\nconst TARGET_IP = \"192.168.86.181\"; // The IP address of your battery (or desired device)\nconst sourceAddress = msg.ip || msg.fromip || msg.address || \"unknown_address\"; // Get source IP from msg\n\n// --- START: IP and Request Filtering Logic ---\nif (sourceAddress !== TARGET_IP) {\n    // Optionally log that you're ignoring a message\n    node.warn(`Ignoring ECHONET Lite message from unknown source: ${sourceAddress}`);\n    return null; // Stop the flow for this message if it's not from the target IP\n}\n\n// Check if payload is a Buffer (raw ECHONET Lite response)\nif (!(payload instanceof Buffer)) {\n    node.warn(\"Payload is not a Buffer. Passing through or ignoring.\");\n    return null; // Or return msg if you want to pass non-Buffer messages\n}\n\n// Basic ECHONET Lite header parsing (needed to get TID)\nconst ehd = payload.readUInt16BE(0); // EHD (ECHONET Lite Header)\nconst tid = payload.readUInt16BE(2); // TID (Transaction ID)\nconst seoj = payload.readUIntBE(4, 3); // SEOJ (Source ECHONET Object)\nconst deoj = payload.readUIntBE(7, 3); // DEOJ (Destination ECHONET Object)\nconst esv = payload.readUInt8(10); // ESV (ECHONET Service)\nconst opc = payload.readUInt8(11); // OPC (Number of properties)\n\n// Retrieve outstanding requests from context\nconst outstandingRequests = flow.get('outstandingRequests') || {};\nconst deviceRequests = outstandingRequests[sourceAddress];\n\nif (!deviceRequests || !deviceRequests.has(tid)) {\n    node.warn(`Ignoring ECHONET Lite response from ${sourceAddress} with TID 0x${tid.toString(16).toUpperCase()}: Not an expected response.`);\n    return null; // Ignore if TID not found for this IP\n}\n\n// If we reach here, it means the IP matches AND the TID matches an outstanding request.\n// Remove the TID from the outstanding requests as it has been received.\ndeviceRequests.delete(tid);\nflow.set('outstandingRequests', outstandingRequests); // Save the updated context\n// --- END: IP and Request Filtering Logic ---\n\nlet parsedProperties = [];\nlet offset = 12; // Start of properties data\n\nlet statusMessage = \"Unknown\"; // Default status message\n\nswitch (esv) {\n    case 0x52: statusMessage = \"Get_SNA (Service Not Available)\"; break;\n    case 0x62: statusMessage = \"GET (Request)\"; break; // This is a request, not a response\n    case 0x72: statusMessage = \"Get_Res (Success)\"; break; // This is the one we expect for successful GET responses\n    case 0x5E: statusMessage = \"Inf_SNA (Information Service Not Available)\"; break; // For INF responses\n    case 0x7E: statusMessage = \"Inf_Res (Information Response)\"; break; // For INF responses\n    case 0x60: statusMessage = \"SET_REQ (Set Request)\"; break; // Set Request from Device\n    case 0x70: statusMessage = \"SET_RES (Set Response)\"; break; // Set Response from Device\n    case 0x50: statusMessage = \"SET_SNA (Set Service Not Available)\"; break; // Set Service Not Available\n    // Add other ESVs as needed\n    default: statusMessage = `ESV: 0x${esv.toString(16).toUpperCase()}`; break;\n}\n\n// Only parse properties if it's a response (0x72 Get_Res, 0x52 Get_SNA, 0x7E Inf_Res, etc.)\nif (esv === 0x72 || esv === 0x52 || esv === 0x7E || esv === 0x5E) { // Expanded for other response types\n    for (let i = 0; i < opc; i++) {\n        const epc = payload.readUInt8(offset); // EPC (Property Code)\n        const pdc = payload.readUInt8(offset + 1); // PDC (Property Data Count)\n\n        let edtBuffer = null;\n        let edtHex = null;\n\n        if (pdc > 0) {\n            edtBuffer = payload.subarray(offset + 2, offset + 2 + pdc);\n            edtHex = '0x' + edtBuffer.toString('hex').toUpperCase();\n        } else {\n            edtHex = '0x'; // No data if PDC is 0\n        }\n\n        let parsedProperty = {\n            epc: '0x' + epc.toString(16).toUpperCase(),\n            pdc: pdc,\n            edt: edtHex,\n            status: (esv === 0x72 || esv === 0x7E) ? \"Success\" : \"Not Available\" // Status for this specific property\n        };\n\n        // Interpret common ECHONET Lite properties\n        if (epc === 0x80) { // Operation status\n            parsedProperty.propertyName = \"Operation Status\";\n            if (pdc === 1 && edtHex === '0x30') {\n                parsedProperty.value = \"ON\";\n            } else if (pdc === 1 && edtHex === '0x31') {\n                parsedProperty.value = \"OFF\";\n            } else {\n                parsedProperty.value = `Unknown (0x${edtHex.substring(2)})`;\n            }\n        } else if (epc === 0x81) { // Installation Location\n            parsedProperty.propertyName = \"Installation Location\";\n            if (pdc === 1) {\n                const locationCode = hexToDec(edtHex);\n                // Standard ECHONET Lite location codes (can be extended)\n                const locations = {\n                    0x01: \"Living Room\", 0x02: \"Dining Room\", 0x03: \"Kitchen\",\n                    0x04: \"Bathroom\", 0x05: \"Toilet\", 0x06: \"Washroom\",\n                    0x07: \"Corridor\", 0x08: \"Room\", 0x09: \"Stairway\",\n                    0x0A: \"Front Door\", 0x0B: \"Balcony\", 0x0C: \"Garden\",\n                    0x0D: \"Garage\", 0x0E: \"Carport\", 0x0F: \"Other\"\n                };\n                parsedProperty.value = locations[locationCode] || `Unknown Code (0x${edtHex.substring(2)})`;\n            } else {\n                parsedProperty.value = edtHex;\n            }\n        } else if (epc === 0x88) { // Fault Status\n            parsedProperty.propertyName = \"Fault Status\";\n            if (pdc === 1) {\n                parsedProperty.value = (edtHex === '0x41') ? \"Fault Occurred\" : \"No Fault\";\n            } else if (pdc > 1) {\n                parsedProperty.value = edtHex; // Keep as hex string for now, for detailed fault codes\n            }\n        } else if (epc === 0x8A) { // Manufacturer Code\n            parsedProperty.propertyName = \"Manufacturer Code\";\n            if (pdc === 3) {\n                parsedProperty.value = edtHex; // Example: OMRON's code might be 0x000084 (just an example)\n            }\n        } else if (epc === 0x9D) { // Supported GET property map (GET property map for Get)\n            parsedProperty.propertyName = \"Supported GET Property Map (Get)\";\n            if (pdc > 0) {\n                const numProps = hexToDec('0x' + edtHex.substring(2, 4)); // First byte is count\n                const supportedEpcs = [];\n                for (let j = 0; j < numProps; j++) {\n                    const epcByte = edtHex.substring(4 + j * 2, 6 + j * 2);\n                    if (epcByte) {\n                        supportedEpcs.push('0x' + epcByte.toUpperCase());\n                    }\n                }\n                parsedProperty.value = supportedEpcs;\n            } else {\n                parsedProperty.value = \"No properties listed\";\n            }\n        } else if (epc === 0x9E) { // Supported SET property map (GET property map for Set)\n            parsedProperty.propertyName = \"Supported SET Property Map (Set)\";\n            if (pdc > 0) {\n                const numProps = hexToDec('0x' + edtHex.substring(2, 4)); // First byte is count\n                const supportedEpcs = [];\n                for (let j = 0; j < numProps; j++) {\n                    const epcByte = edtHex.substring(4 + j * 2, 6 + j * 2);\n                    if (epcByte) {\n                        supportedEpcs.push('0x' + epcByte.toUpperCase());\n                    }\n                }\n                parsedProperty.value = supportedEpcs;\n            } else {\n                parsedProperty.value = \"No properties listed\";\n            }\n        }\n        // Add other device class-specific properties (Storage Battery: 0x027D)\n        else if (epc === 0xE4) { // Measured Remaining Capacity 1 (%)\n            parsedProperty.propertyName = \"Battery Remaining Capacity\";\n            if (pdc === 1) {\n                parsedProperty.value = hexToDec(edtHex);\n                parsedProperty.units = \"%\";\n            } else {\n                parsedProperty.value = edtHex;\n            }\n        }\n        else if (epc === 0xAA) { // Self-node Instance List S\n            parsedProperty.propertyName = \"Self-node Instance List S\";\n            parsedProperty.value = parseInstanceList(edtHex); // Re-using parseInstanceList\n        }\n        else if (epc === 0xAB) { // Self-node Class List S\n            parsedProperty.propertyName = \"Self-node Class List S\";\n            // This property usually lists the device classes supported by the controller itself.\n            // Format is similar to instance list but for class codes (2 bytes each)\n            if (edtHex && pdc > 0) {\n                const hexString = edtHex.substring(2);\n                const classes = [];\n                for (let j = 0; j < hexString.length; j += 4) { // 2 bytes per class\n                    if (j + 4 <= hexString.length) {\n                        classes.push('0x' + hexString.substring(j, j + 4).toUpperCase());\n                    }\n                    }\n                parsedProperty.value = classes;\n            } else {\n                parsedProperty.value = edtHex;\n            }\n        }\n        else if (epc === 0xC1) { // Capacity for grid connection\n            parsedProperty.propertyName = \"Grid Connection Capacity/Status\";\n            if (pdc === 1) {\n                const val = hexToDec(edtHex);\n                // Based on observation, 0x03 seems to be an enabled/ready state\n                switch (val) {\n                    case 0x00: parsedProperty.value = \"Not Connected\"; break;\n                    case 0x01: parsedProperty.value = \"Connected\"; break;\n                    case 0x02: parsedProperty.value = \"Connection Possible\"; break;\n                    case 0x03: parsedProperty.value = \"Connection Enabled/Ready\"; break; // Common interpretation for your value\n                    default: parsedProperty.value = `Unknown Code (0x${val.toString(16).toUpperCase()})`;\n                }\n            } else {\n                parsedProperty.value = edtHex;\n            }\n        }\n        else if (epc === 0xC2) { // Rated power for grid connection\n            parsedProperty.propertyName = \"Grid Connection Rated Power Status\";\n            if (pdc === 1) {\n                const val = hexToDec(edtHex);\n                // Similar to 0xC1, likely a status/enablement, not a direct power value given 1 byte\n                switch (val) {\n                    case 0x00: parsedProperty.value = \"Disabled\"; break;\n                    case 0x01: parsedProperty.value = \"Enabled\"; break;\n                    case 0x03: parsedProperty.value = \"Enabled (Full Capacity)\"; break; // Based on observed 0x03\n                    default: parsedProperty.value = `Unknown Code (0x${val.toString(16).toUpperCase()})`;\n                }\n            } else if (pdc === 2) { // If it were a power value (e.g., Watts)\n                const val = parseInt(edtHex.substring(2), 16);\n                if (val & 0x8000) { parsedProperty.value = val - 0x10000; } // Signed 16-bit\n                else { parsedProperty.value = val; }\n                parsedProperty.units = \"W\";\n            } else {\n                parsedProperty.value = edtHex;\n            }\n        }\n        else if (epc === 0xCF) { // PV-linked status\n            parsedProperty.propertyName = \"PV-Linked Status\";\n            if (pdc === 1) {\n                const val = hexToDec(edtHex);\n                switch (val) {\n                    case 0x00: parsedProperty.value = \"Not Linked\"; break;\n                    case 0x01: parsedProperty.value = \"Linked\"; break;\n                    case 0x02: parsedProperty.value = \"Operating PV\"; break; // Example interpretation\n                    default: parsedProperty.value = `Unknown Code (0x${val.toString(16).toUpperCase()})`;\n                }\n            } else {\n                parsedProperty.value = edtHex;\n            }\n        }\n        else if (epc === 0xDA) { // Remaining stored electricity amount 2 (likely detailed status)\n            parsedProperty.propertyName = \"Battery Detailed Status\";\n            if (pdc === 1) {\n                const val = hexToDec(edtHex);\n                // Based on ECHONET Lite common patterns and your observed 0x46 for 100%\n                switch (val) {\n                    case 0x41: parsedProperty.value = \"Charging\"; break;\n                    case 0x42: parsedProperty.value = \"Discharging\"; break;\n                    case 0x43: parsedProperty.value = \"Idle / Standby\"; break;\n                    case 0x44: parsedProperty.value = \"Full / Charged\"; break;\n                    case 0x45: parsedProperty.value = \"Error / Malfunction\"; break;\n                    case 0x46: parsedProperty.value = \"Charging Complete / Full Standby\"; break; // Based on your observation (100% capacity)\n                    // You will need to confirm these mappings by observing the battery!\n                    default: parsedProperty.value = `Unknown Code (0x${val.toString(16).toUpperCase()})`;\n                }\n            } else {\n                parsedProperty.value = edtHex;\n            }\n        }\n        // General \"Unknown EPC\" fallback\n        else {\n            parsedProperty.propertyName = `Unknown EPC 0x${epc.toString(16).toUpperCase()}`;\n        }\n\n        parsedProperties.push(parsedProperty);\n        offset += (2 + pdc); // Move offset to the next property\n    }\n} else {\n    node.warn(`Received ECHONET Lite message with unexpected ESV: 0x${esv.toString(16).toUpperCase()} for DEOJ: 0x${deoj.toString(16).toUpperCase()}`);\n    node.warn(`Raw payload: ${payload.toString('hex')}`);\n    return null; // Don't process non-response ESVs if you only want responses\n}\n\n// Set msg.payload to the parsed object\nmsg.payload = {\n    timestamp: Date.now(),\n    remoteAddress: sourceAddress, // This will now always be the TARGET_IP if it passes the filter\n    ehd: '0x' + ehd.toString(16).toUpperCase(),\n    tid: '0x' + tid.toString(16).toUpperCase(),\n    seoj: '0x' + seoj.toString(16).toUpperCase(),\n    deoj: '0x' + deoj.toString(16).toUpperCase(),\n    esv: '0x' + esv.toString(16).toUpperCase(),\n    opc: opc,\n    status: statusMessage,\n    properties: parsedProperties\n};\n\nflow.set(\"batteryData\", msg.payload); \nmsg.topic = \"battery\";\nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":430,"y":940,"wires":[["4c55a5b118b826f6"]]},{"id":"4c55a5b118b826f6","type":"debug","z":"b956abd7fd2a06d1","name":"ECHONET Lite Response","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":1130,"y":960,"wires":[]},{"id":"d6dfdecaadf17acf","type":"inject","z":"b956abd7fd2a06d1","name":"Request All Data","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"request_all","payload":"","payloadType":"date","x":240,"y":1180,"wires":[["2badfb32ececd3fd"]]},{"id":"2badfb32ececd3fd","type":"function","z":"b956abd7fd2a06d1","name":"Prepare Discovery Request","func":"const controllerSEOJ = Buffer.from('05FF01', 'hex');\nconst nodeProfileDEOJ = Buffer.from('0EF001', 'hex'); // Target Node Profile\nconst service = 0x62; // GET service\nconst epc = 0xD6; // Self-node instance list S\nconst pdc = 0x00; // For GET\n\nconst tid = Buffer.from('0001', 'hex'); // Transaction ID\n\nconst buffer = Buffer.concat([\n    Buffer.from('1081', 'hex'),\n    tid,\n    controllerSEOJ,\n    nodeProfileDEOJ,\n    Buffer.from([service]),\n    Buffer.from([0x01]), // OPC (1 property)\n    Buffer.from([epc, pdc])\n]);\n\nmsg.payload = buffer;\nmsg.ip = \"224.0.23.0\"; // Multicast address for discovery\nmsg.port = 3610;\nmsg.topic = 'discovery_request';\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":520,"y":1180,"wires":[["8ae46cc9dbd867e6"]]},{"id":"8ae46cc9dbd867e6","type":"udp out","z":"b956abd7fd2a06d1","name":"UDP Out (Multicast Discovery)","addr":"224.0.23.0","iface":"","port":"3610","ipv":"udp4","outport":"","base64":false,"multicast":"multi","x":850,"y":1180,"wires":[]},{"id":"5ab1126e55665fe4","type":"debug","z":"b956abd7fd2a06d1","name":"raw buffer data","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":380,"y":900,"wires":[]},{"id":"9ae2bdd297c157cc","type":"function","z":"b956abd7fd2a06d1","d":true,"name":"Prepare AiSEG Request","func":"","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":450,"y":780,"wires":[["241fd561c835c6e4"]]},{"id":"http_in","type":"http in","z":"b956abd7fd2a06d1","d":true,"name":"Trigger Battery Capacity API","url":"/api/battery-capacity","method":"get","x":200,"y":2000,"wires":[["compose_udp"]]},{"id":"compose_udp","type":"function","z":"b956abd7fd2a06d1","d":true,"name":"Compose UDP Request with TID","func":"// Generate unique TID\nlet tid = Math.floor(Math.random() * 0xffff);\nflow.set(\"expected_tid\", tid);\n\nlet tidBuffer = Buffer.alloc(2);\ntidBuffer.writeUInt16BE(tid);\n\n// Compose ECHONET Lite frame\nmsg.payload = Buffer.concat([\n  Buffer.from([0x10, 0x81]),      // EHD\n  tidBuffer,                      // TID\n  Buffer.from([0x02, 0x88]),      // SEOJ\n  Buffer.from([0x05, 0xFF]),      // DEOJ\n  Buffer.from([0x62, 0x01, 0xE0, 0x00]) // ESV, OPC, EPC, PDC\n]);\n\nmsg.port = 3610;\nmsg.ip = \"192.168.x.x\"; // Replace with battery IP\nreturn msg;","outputs":1,"x":480,"y":2000,"wires":[["udp_out","start_timeout"]]},{"id":"udp_out","type":"udp out","z":"b956abd7fd2a06d1","d":true,"name":"Send UDP Request","x":750,"y":2000,"wires":[]},{"id":"start_timeout","type":"delay","z":"b956abd7fd2a06d1","d":true,"name":"Start Timeout Countdown","pauseType":"delay","timeout":"5","timeoutUnits":"seconds","outputs":1,"x":810,"y":2080,"wires":[["timeout_check"]]},{"id":"timeout_check","type":"function","z":"b956abd7fd2a06d1","d":true,"name":"Check for Timed Out TID","func":"if (flow.get(\"expected_tid\") !== null) {\n    flow.set(\"expected_tid\", null);\n    msg.payload = { error: \"Battery device did not respond in time.\" };\n    msg.statusCode = 504;\n    return msg;\n}\nreturn null;","outputs":1,"x":1150,"y":2100,"wires":[["http_response"]]},{"id":"udp_in","type":"udp in","z":"b956abd7fd2a06d1","d":true,"name":"Receive UDP Response","x":850,"y":2040,"wires":[["parse_response"]]},{"id":"parse_response","type":"function","z":"b956abd7fd2a06d1","d":true,"name":"Parse Battery Response","func":"let payload = msg.payload;\nlet receivedTid = payload.readUInt16BE(2);\nlet expectedTid = flow.get(\"expected_tid\");\nif (receivedTid !== expectedTid) return null; // Ignore unrelated response\nflow.set(\"expected_tid\", null);\n\n// Parse EPC E0 (Battery Capacity)\nlet epcIndex = payload.indexOf(0xE0);\nif (epcIndex !== -1 && payload[epcIndex + 1] > 0) {\n    let pdc = payload[epcIndex + 1];\n    let dataBytes = payload.slice(epcIndex + 2, epcIndex + 2 + pdc);\n    let capacity = dataBytes.readUInt16BE(); // adjust based on actual format\n    msg.payload = { batteryCapacity: capacity + \" Wh\" };\n} else {\n    msg.payload = { error: \"Malformed battery data\" };\n    msg.statusCode = 500;\n}\nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":1090,"y":2060,"wires":[["suppress_repeats"]]},{"id":"suppress_repeats","type":"rbe","z":"b956abd7fd2a06d1","d":true,"name":"Suppress Repeat Capacity","func":"rbe","gap":"","start":"","inout":"out","septopics":true,"property":"payload","topi":"topic","x":1340,"y":2060,"wires":[["http_response"]]},{"id":"http_response","type":"http response","z":"b956abd7fd2a06d1","d":true,"name":"Send API Response","x":1600,"y":2100,"wires":[]},{"id":"catch_all","type":"catch","z":"b956abd7fd2a06d1","d":true,"name":"Catch Flow Errors","scope":null,"uncaught":false,"x":290,"y":2140,"wires":[["format_error"]]},{"id":"format_error","type":"function","z":"b956abd7fd2a06d1","d":true,"name":"Format Catch Error","func":"msg.payload = { error: msg.error.message || \"Unhandled error\" };\nmsg.statusCode = 500;\nreturn msg;","outputs":1,"x":1370,"y":2140,"wires":[["http_response"]]},{"id":"241fd561c835c6e4","type":"udp out","z":"b956abd7fd2a06d1","d":true,"name":"UDP Out (Solar Panel)","addr":"192.168.86.216","iface":"","port":"3610","ipv":"udp4","outport":"","base64":false,"multicast":"false","x":700,"y":780,"wires":[]},{"id":"0533447ea29c81d5","type":"udp out","z":"b956abd7fd2a06d1","d":true,"name":"UDP Out (Cube J1)","addr":"192.168.86.225","iface":"","port":"3610","ipv":"udp4","outport":"","base64":false,"multicast":"false","x":710,"y":740,"wires":[]},{"id":"ec0dc701997716e0","type":"function","z":"b956abd7fd2a06d1","d":true,"name":"Prepare Cube J1 Request","func":"// Function node to request 0x9D (Supported GET Property Map) from a hypothetical Solar Power Generation Device object on Cube J1\nconst controllerSEOJ = Buffer.from('05FF01', 'hex'); // Your controller's SEOJ\nconst solarPanelDEOJ = Buffer.from('028801', 'hex'); // Solar Power Generation Device, instance 01 (common)\nconst service = 0x62; // GET service\n\nconst epc1 = 0x9D; // Requesting the Supported GET Property Map\nconst pdc1 = 0x00; // PDC is 0x00 for a GET request\n\nconst tid = Buffer.from('000A', 'hex'); // Increment TID\n\nconst buffer = Buffer.concat([\n    Buffer.from('1081', 'hex'), // EHD\n    tid, // TID\n    controllerSEOJ,              // SEOJ\n    solarPanelDEOJ,              // DEOJ (Targeting the solar panel object)\n    Buffer.from([service]),      // ESV\n    Buffer.from([0x01]),         // OPC (1 property)\n    Buffer.from([epc1, pdc1])\n]);\n\nmsg.payload = buffer;\nmsg.ip = \"192.168.86.225\"; // Cube J1's IP\nmsg.port = 3610;\nmsg.topic = 'cube_j1_solar_028801_9D_request';\nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":450,"y":740,"wires":[["0533447ea29c81d5"]]},{"id":"start_poll","type":"inject","z":"b956abd7fd2a06d1","name":"Poll AiSEG Realtime Data","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"300","crontab":"","once":true,"onceDelay":"0.1","topic":"","payload":"","payloadType":"date","x":220,"y":580,"wires":[["http_get_realtime_data"]]},{"id":"http_get_realtime_data","type":"http request","z":"b956abd7fd2a06d1","name":"GET top_val.cgi (Realtime)","method":"GET","ret":"txt","paytoqs":"ignore","url":"http://192.168.86.216/get/top_val.cgi","tls":"","persist":false,"proxy":"","insecureHTTPParser":false,"authType":"basic","senderr":false,"headers":[],"x":500,"y":580,"wires":[["debug_raw_realtime_response","parse_aiseg_realtime_data"]]},{"id":"debug_raw_realtime_response","type":"debug","z":"b956abd7fd2a06d1","name":"Raw top_val.cgi Response","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":780,"y":580,"wires":[]},{"id":"parse_aiseg_realtime_data","type":"function","z":"b956abd7fd2a06d1","name":"Parse AiSEG Realtime Data","func":"const htmlContent = msg.payload; // msg.payload will contain the script/HTML from top_val.cgi\nconst data = {};\n\n// Helper function to extract a variable value from the script content\n// It specifically looks for 'var varNameT = \"VALUE\";' or 'var varNameT = VALUE;' format\nfunction extractScriptVar(varName) {\n    const regex = new RegExp(`var\\\\s+${varName}T\\\\s*=\\\\s*[\"']?([^\"';]*)[\"']?;`);\n    const match = htmlContent.match(regex);\n\n    if (match && match[1] !== undefined) {\n        let value = match[1].trim();\n\n        // Handle the specific case of '&nbsp;' for empty fields\n        value = value.replace(/&nbsp;/g, '').trim();\n\n        // Convert common \"empty\" indicators to 0 for numerical fields\n        if (value === \"\" || value === \"-\") {\n            return 0; // Return 0 for empty or \"-\" for numerical interpretation\n        }\n\n        // Attempt to parse as a float (for numbers)\n        const parsedValue = parseFloat(value);\n        if (!isNaN(parsedValue)) {\n            return parsedValue; // Return as a number if successful\n        }\n        // If it's not a number (e.g., \"bunkion\"), return the cleaned string value\n        return value;\n    }\n    return null; // Return null if the variable is not found in the content\n}\n\n// Extracting all the variables identified in your top_val.cgi response\n// These names correspond to the 'varNameT' in the AiSEG's top_val.cgi script\ndata.selElec = extractScriptVar('selElec'); // Electricity Sold (売電)\ndata.selUnit = extractScriptVar('selUnit'); // Selling Unit Price (売電単価)\ndata.buyElec = extractScriptVar('buyElec'); // Electricity Bought (買電)\ndata.buyUnit = extractScriptVar('buyUnit'); // Buying Unit Price (買電単価)\ndata.enefarm = extractScriptVar('enefarm'); // Ene-Farm/Fuel Cell Generation (エネファーム)\ndata.soler = extractScriptVar('soler');     // Total Solar Power Generation (from solerT)\ndata.soler1 = extractScriptVar('soler1');   // Solar Power Generation 1 (if available)\ndata.soler2 = extractScriptVar('soler2');   // Solar Power Generation 2 (if available)\ndata.batteryCharge = extractScriptVar('batteryCharge'); // Battery Charging Status (-1: off, 0: not charging, 1: charging)\ndata.batteryPer = extractScriptVar('batteryPer'); // Battery Percentage (蓄電池残量パーセント)\ndata.use = extractScriptVar('use');         // Current Usage/Consumption (使用量)\ndata.useBuy = extractScriptVar('useBuy');   // Usage from Bought Electricity (買電による使用量)\ndata.useSb = extractScriptVar('useSb');     // Usage from Battery (蓄電池による使用量)\ndata.gene = extractScriptVar('gene');       // Generation (could be sum of solar/enefarm, or total output)\ndata.div = extractScriptVar('div');         // Div control, likely display related ('bunkion' seems to be a display state)\ndata.sbType = extractScriptVar('sbType');   // Storage battery type\ndata.sbState = extractScriptVar('sbState'); // Storage battery state\n\n// Optionally, convert batteryCharge to a more descriptive status string\nif (data.batteryCharge === -1) {\n    data.batteryChargeStatus = \"Off\";\n} else if (data.batteryCharge === 0) {\n    data.batteryChargeStatus = \"Not Charging\";\n} else if (data.batteryCharge === 1) {\n    data.batteryChargeStatus = \"Charging\";\n} else {\n    data.batteryChargeStatus = \"Unknown\"; // For any other unexpected value\n}\n\nmsg.payload = data; // Set the payload to an object containing all extracted data\nmsg.topic = \"solar\"; \nflow.set(\"solarData\", msg.payload); \nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":780,"y":620,"wires":[["debug_parsed_data"]]},{"id":"debug_parsed_data","type":"debug","z":"b956abd7fd2a06d1","name":"Parsed AiSEG Data","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":1050,"y":620,"wires":[]},{"id":"9d08183df505d140","type":"ui-button","z":"b956abd7fd2a06d1","group":"bba524eeeb008f07","name":"","label":"Refresh","order":1,"width":0,"height":0,"emulateClick":false,"tooltip":"","color":"","bgcolor":"","className":"","icon":"","iconPosition":"left","payload":"","payloadType":"str","topic":"topic","topicType":"msg","buttonColor":"","textColor":"","iconColor":"","enableClick":true,"enablePointerdown":false,"pointerdownPayload":"","pointerdownPayloadType":"str","enablePointerup":false,"pointerupPayload":"","pointerupPayloadType":"str","x":100,"y":480,"wires":[["http_get_realtime_data","c1c73a0e41f01691"]]},{"id":"inject_weather","type":"inject","z":"b956abd7fd2a06d1","name":"Update Weather","props":[],"repeat":"3600","crontab":"","once":true,"onceDelay":0.1,"topic":"","x":130,"y":180,"wires":[["exec_curl_weather"]]},{"id":"exec_curl_weather","type":"exec","z":"b956abd7fd2a06d1","command":"curl -s \"https://api.open-meteo.com/v1/forecast?latitude=35.6895&longitude=139.6917&current=temperature_2m,weathercode&timezone=Asia%2FTokyo\"","addpay":false,"append":"","useSpawn":"false","timer":"","winHide":false,"oldrc":false,"name":"Curl: Open-Meteo","x":320,"y":180,"wires":[["parse_json_weather"],[],[]]},{"id":"parse_json_weather","type":"json","z":"b956abd7fd2a06d1","name":"Parse JSON","property":"payload","action":"","pretty":false,"x":500,"y":180,"wires":[["map_weather_code"]]},{"id":"map_weather_code","type":"function","z":"b956abd7fd2a06d1","name":"Map Code → Emoji + Icon","func":"// Extract Open-Meteo values\nlet current = msg.payload.current || {};\nlet temp = current.temperature_2m;\nlet code = current.weathercode;\n\nlet emoji = \"❔\";\nlet iconName = \"weather-alert\";\n\nswitch (code) {\n    case 0: emoji = \"☀️\"; iconName = \"weather-clear\"; break;            // Clear sky\n    case 1: emoji = \"🌤️\"; iconName = \"weather-mostly-clear\"; break;     // Mainly clear\n    case 2: emoji = \"⛅\"; iconName = \"weather-partly-cloudy\"; break;     // Partly cloudy\n    case 3: emoji = \"☁️\"; iconName = \"weather-cloudy\"; break;            // Overcast\n    case 45: case 48: emoji = \"🌫️\"; iconName = \"weather-hazy\"; break;   // Fog & depositing rime\n    case 51: case 53: case 55: emoji = \"🌦️\"; iconName = \"weather-showers\"; break; // Drizzle\n    case 56: case 57: emoji = \"🌧️\"; iconName = \"weather-showers\"; break; // Freezing drizzle\n    case 61: case 63: case 65: emoji = \"🌧️\"; iconName = \"weather-rain\"; break; // Rain\n    case 66: case 67: emoji = \"🌧️❄️\"; iconName = \"weather-rain\"; break; // Freezing rain\n    case 71: case 73: case 75: emoji = \"🌨️\"; iconName = \"weather-snow\"; break; // Snow fall\n    case 77: emoji = \"❄️\"; iconName = \"weather-snow\"; break;              // Snow grains\n    case 80: case 81: case 82: emoji = \"⛈️\"; iconName = \"weather-rain-heavy\"; break; // Rain showers\n    case 85: case 86: emoji = \"🌨️\"; iconName = \"weather-snow-heavy\"; break; // Snow showers\n    case 95: emoji = \"⛈️\"; iconName = \"weather-tstorm\"; break;          // Thunderstorm\n    case 96: case 99: emoji = \"🌩️\"; iconName = \"weather-tstorm\"; break; // Thunder + hail\n    default: emoji = \"❔\"; iconName = \"weather-alert\";\n}\n\n// Store result in flow context\nflow.set(\"weatherData\", {\n    temp: temp,\n    weathercode: code,\n    icon_emoji: emoji,\n    icon_name: iconName\n});\n\n// For debugging\nmsg.payload = {\n    temp,\n    weathercode: code,\n    icon_emoji: emoji,\n    icon_name: iconName\n};\nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":710,"y":180,"wires":[["weather_debug"]]},{"id":"weather_debug","type":"debug","z":"b956abd7fd2a06d1","name":"Weather Parsed","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","x":940,"y":180,"wires":[]},{"id":"b83ed73ca40d78a6","type":"function","z":"b956abd7fd2a06d1","name":"Analyze and Consolidate Available Energy Data","func":"let baseline = 0.35; // average \"always-on\" load/use, based on observation and Japanese household average\n// low rate energy period: 23:00 - 07:00\n\n// settings from battery system\nconst batterySafetyCharge = 30; // charge kept at all times as an emergency backup\nconst batteryMaximumLowRateCharge= 50; // maximum to which battery charges from the net after 23:00 (if needed) with low rate nighttime energy\n// note that AI in the battery system can override the values and keep a 100% charge at all times in case of bad weather or emergencies.\n\n// --- Retrieve battery & solar ---\nlet solar = flow.get(\"solarData\");\nlet battery = flow.get(\"batteryData\");\nif (!solar || !battery || !battery.properties) return [null];\n\n// --- Extract values ---\nlet gen = solar.soler || 0;\nlet use = solar.use || 0;\nlet buying = solar.buyElec || 0;\nlet selling = solar.selElec || 0;\nlet battery_pct = battery.properties.find(p => p.epc === \"0xE4\")?.value;\nif (battery_pct === undefined) return [null];\n\n// --- Configurable Parameters ---\nconst capacity = 8.8; // Usable battery capacity in kWh (nominal 9.8 kWh)\nconst intervalMinutes = 5;\nconst durationMinutes = flow.get(\"durationMinutes\") || 30;\nconst windowSize = durationMinutes / intervalMinutes;\n\nconst nominalSolarCapacity = 5.04; // in kW, based on installer spec\nif (gen > nominalSolarCapacity) {\n    gen = nominalSolarCapacity; // clamp to expected max\n}\n\nlet solarEfficiency = 0;\nif (nominalSolarCapacity > 0) {\n    solarEfficiency = gen / nominalSolarCapacity;\n}\n\n// --- History Tracking ---\nlet pctHistory = flow.get(\"batteryPctHistory\") || [];\npctHistory.push(battery_pct);\nif (pctHistory.length > windowSize) pctHistory.shift();\nflow.set(\"batteryPctHistory\", pctHistory);\n\n// --- Delta Calculation ---\nlet delta = 0;\nif (pctHistory.length === windowSize) {\n    delta = battery_pct - pctHistory[0];\n}\nconst maxBatteryRate = 4.0; // max charge/discharge throughput (kW)\n\n// --- Rate Calculation ---\nlet delta_pct = pctHistory.length === windowSize ? battery_pct - pctHistory[0] : 0;\nlet rate_kWh = (delta_pct / 100) * capacity;\nlet rate_kW = rate_kWh / (durationMinutes / 60); // Convert duration to hours\nrate_kW = Math.max(Math.min(rate_kW, maxBatteryRate), -maxBatteryRate);\n\n// --- Current Rate (short-term) ---\nlet currentRate_kW = 0;\nif (pctHistory.length >= 2) {\n    let shortDelta_pct = battery_pct - pctHistory[pctHistory.length - 2];\n    let shortRate_kWh = (shortDelta_pct / 100) * capacity;\n    currentRate_kW = shortRate_kWh / (intervalMinutes / 60); // Convert interval to hours\n    currentRate_kW = Math.max(Math.min(currentRate_kW, maxBatteryRate), -maxBatteryRate);\n}\n\n// --- Moving Average for Graph Smoothing ---\nlet rateBuffer = flow.get(\"batteryRateHistory\") || [];\nrateBuffer.push(currentRate_kW);\nif (rateBuffer.length > windowSize) rateBuffer.shift();\nflow.set(\"batteryRateHistory\", rateBuffer);\n\nlet smoothed_rate_kW = rateBuffer.reduce((a, b) => a + b, 0) / rateBuffer.length;\nsmoothed_rate_kW = Math.max(Math.min(smoothed_rate_kW, maxBatteryRate), -maxBatteryRate);\n\n// --- Confidence Tagging ---\nlet confidence = \"high\";\nif (Math.abs(delta_pct) < 0.3 && Math.abs(rate_kW) === 0 && gen > 0) {\n    confidence = \"low\"; // possible telemetry rounding\n}\n\n// --- Determine Idle Status More Accurately ---\nlet isIdle = rate_kW === 0 && battery_pct === pctHistory[pctHistory.length - 1] && gen < use && buying === 0;\n\n// --- Status Logic ---\nlet status = \"idle\";\nif (battery_pct > 30) {\n    if (buying === 0 && gen < use) status = \"discharging\";\n    if (buying > 0 && gen < use) status = \"idle\";\n    if (gen >= use && battery_pct > pctHistory[0]) status = \"charging\";\n}\nif (currentRate_kW < 0) status = \"discharging\";\nif (currentRate_kW === 0) status = \"idle\";\nif (currentRate_kW > 0) status = \"charging\";\n\nconst minSafePct = 10;\nif (battery_pct < minSafePct) status = \"idle\"; // prevent misleading discharge classification\n\n\n// --- Household Calculation ---\nlet adjustedUse = use; // default: use equals household consumption\n\n// If household is silently powered by battery (use suppressed during discharge)\nif (status === \"discharging\" && use <= baseline && rate_kW < 0) {\n    adjustedUse = Math.abs(rate_kW); // Use is masked, but battery discharge reveals real consumption\n}\n\n// If charging from grid, remove battery charge contribution from household\nif (status === \"charging\" && buying > 0) {\n    let batteryGridCharge = Math.min(rate_kW, buying);\n    adjustedUse = Math.max(0, use - batteryGridCharge); // Avoid negative use\n}\n\nlet household = parseFloat(adjustedUse.toFixed(2));\n\nlet household_source = \"direct-metered\";\nif (status === \"discharging\" && use <= baseline && rate_kW < 0) {\n    household_source = \"inferred-from-battery\";\n}\n\nlet chargingSource = \"unknown\";\nif (status === \"charging\") {\n    if (gen > use) chargingSource = \"solar\";\n    else if (buying > 0) chargingSource = \"grid\";\n}\nif (status === \"charging\") {\n    if (gen > use + rate_kW) chargingSource = \"solar-surplus\";\n    else if (buying >= rate_kW) chargingSource = \"grid\";\n}\n\n// --- Weather ---\nlet weather = flow.get(\"weatherData\");\nlet sunData = flow.get(\"sunData\");\n\n// --- Timestamp ---\nlet timestamp = new Date().toLocaleTimeString(\"ja-JP\", {\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n    hour12: false,\n    timeZone: \"Asia/Tokyo\"\n});\n\n// --- Final Output ---\nmsg.payload = {\n    timestamp,\n    sundata: {\n        sunrise: sunData.sunrise, \n        sunset: sunData.sunset\n    },    \n    solar: {\n        generation_kW: gen,\n        usage_kW: use,\n        buy_kW: buying,\n        sell_kW: selling,\n        efficiency: parseFloat(solarEfficiency.toFixed(3))\n    },\n    battery: {\n        percent: battery_pct,\n        status: status,\n        rate_kW: parseFloat(smoothed_rate_kW.toFixed(2)),     // For graph\n        current_rate_kW: parseFloat(currentRate_kW.toFixed(2)), // For real-time logic\n        source: chargingSource,\n        confidence,\n        isIdle\n    },\n    calculation: {\n        household_kW: parseFloat(household.toFixed(2)),\n        delta_pct: pctHistory.length === windowSize ? delta : null,\n        durationMinutes,\n        capacity_kWh: capacity\n    },\n    weather\n};\n\nglobal.set(\"energyData\", msg.payload);\n\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":420,"y":100,"wires":[["44ab9ba16bf0525c"]]},{"id":"3d0ce91cf0a75a65","type":"inject","z":"b956abd7fd2a06d1","name":"Consolidate Data","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"300","crontab":"","once":true,"onceDelay":"30","topic":"","payload":"","payloadType":"date","x":130,"y":80,"wires":[["b83ed73ca40d78a6"]]},{"id":"44ab9ba16bf0525c","type":"debug","z":"b956abd7fd2a06d1","name":"Consolidate Raw Output","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":730,"y":120,"wires":[]},{"id":"inject_sun","type":"inject","z":"b956abd7fd2a06d1","name":"Fetch Sunrise/Sunset","props":[],"repeat":"86400","crontab":"","once":true,"onceDelay":0.1,"topic":"","x":140,"y":240,"wires":[["exec_sun"]]},{"id":"exec_sun","type":"exec","z":"b956abd7fd2a06d1","command":"curl -s \"https://api.sunrise-sunset.org/json?lat=35.6895&lng=139.6917&formatted=0&tzid=Asia/Tokyo\"","addpay":false,"append":"","useSpawn":"false","timer":"","winHide":false,"oldrc":false,"name":"Curl: Sunrise-Sunset.org","x":390,"y":240,"wires":[["json_sun"],[],[]]},{"id":"json_sun","type":"json","z":"b956abd7fd2a06d1","name":"Parse JSON","property":"payload","action":"","pretty":false,"x":590,"y":240,"wires":[["map_sun"]]},{"id":"map_sun","type":"function","z":"b956abd7fd2a06d1","name":"Extract Sunrise/Sunset","func":"// Extract and store sunrise/sunset data\nlet results = msg.payload.results || {};\n\nflow.set(\"sunData\", {\n    sunrise: results.sunrise,\n    sunset: results.sunset,\n    solar_noon: results.solar_noon,\n    day_length: results.day_length\n});\n\nmsg.payload = flow.get(\"sunData\");\nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":790,"y":240,"wires":[["debug_sun"]]},{"id":"debug_sun","type":"debug","z":"b956abd7fd2a06d1","name":"Sun Times Output","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","x":1010,"y":240,"wires":[]},{"id":"inject1","type":"inject","z":"b956abd7fd2a06d1","name":"Query Node Profile EPCs","props":[],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":250,"y":1140,"wires":[["function1"]]},{"id":"function1","type":"function","z":"b956abd7fd2a06d1","name":"Build UDP Multicast Request","func":"// Controller & target (Node Profile Object)\nconst controllerSEOJ = Buffer.from(\"05FF01\", \"hex\");\nconst nodeProfileDEOJ = Buffer.from(\"0EF001\", \"hex\");\nconst serviceCode = 0x62; // ESV: Get\n\n// EPCs we want to query\nconst epcs = [\"80\", \"8A\", \"9F\", \"9E\"];\nconst opc = epcs.length;\n\n// Build frame header\nconst ehd = Buffer.from(\"1081\", \"hex\"); // ECHONET Lite header\nconst tid = Buffer.from(\"1234\", \"hex\");  // Transaction ID\nconst seoj = controllerSEOJ;\nconst deoj = nodeProfileDEOJ;\nconst esv = Buffer.from([serviceCode]);\nconst opcBuf = Buffer.from([opc]);\n\nconst tidLabelMap = flow.get('tidLabelMap') || {};\ntidLabelMap[tid] = 'node_profile';\nflow.set('tidLabelMap', tidLabelMap);\n\n// Build property requests (EPC + PDC=0)\nconst epcBlocks = Buffer.concat(epcs.map(code => Buffer.from([parseInt(code, 16), 0x00])));\n\nconst frame = Buffer.concat([ehd, tid, seoj, deoj, esv, opcBuf, epcBlocks]);\n\nmsg.payload = frame;\nmsg.ip = \"224.0.23.0\"; // ECHONET Lite multicast address\nmsg.port = 3610;\nmsg.tid = \"1234\";\nmsg.topic = \"ECHONET_NodeProfile_Query\";\nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":540,"y":1140,"wires":[["udp1"]]},{"id":"udp1","type":"udp out","z":"b956abd7fd2a06d1","name":"Send UDP Multicast","addr":"","iface":"","port":"","ipv":"udp4","outport":"","base64":false,"x":860,"y":1140,"wires":[]},{"id":"cea83369f876af37","type":"GSheet","z":"b956abd7fd2a06d1","creds":"166c30c33417c9d1","method":"append","action":"","sheet":"1i6UMpjJ8Or3lPP7qO8rwZLXHEhfkSmlhZtVGgcL2ES0","cells":"Sheet1!A2:E2","flatten":false,"name":"","x":1070,"y":860,"wires":[[]]},{"id":"7e145fea23439353","type":"function","z":"b956abd7fd2a06d1","name":"Parse ECHONET Lite for Logging","func":"const payload = msg.payload;\nconst sourceAddress = msg.ip || msg.fromip || msg.address || \"unknown_address\";\nconst TARGET_IP = \"192.168.86.181\";\nconst logAllEPCs = true;\n\nif (sourceAddress !== TARGET_IP || !(payload instanceof Buffer)) {\n    return null;\n}\n\nconst ehd = payload.readUInt16BE(0);\nconst tid = payload.readUInt16BE(2);\nconst esv = payload.readUInt8(10);\nconst opc = payload.readUInt8(11);\n\nlet offset = 12;\nconst parsed = [];\n\nfor (let i = 0; i < opc; i++) {\n    const epc = payload.readUInt8(offset);\n    const pdc = payload.readUInt8(offset + 1);\n    const edt = payload.subarray(offset + 2, offset + 2 + pdc);\n    const edtHex = edt.length ? '0x' + edt.toString('hex').toUpperCase() : '0x';\n    const status = (esv === 0x72 || esv === 0x7E) ? \"Success\" : \"Not Available\";\n    if (!logAllEPCs && status !== \"Success\") {\n        offset += (2 + pdc);\n        continue;\n    }\n\n    let propertyName = `EPC 0x${epc.toString(16).toUpperCase()}`;\n    let value = edtHex;\n    let units = \"\";\n\n    switch (epc) {\n        case 0xE4:\n            propertyName = \"Battery Remaining Capacity\";\n            value = edt.readUInt8(0); // e.g. 93\n            units = \"%\";\n            break;\n        case 0xDA:\n            propertyName = \"Battery Detailed Status\";\n            value = {\n                0x41: \"Charging\",\n                0x42: \"Discharging\",\n                0x46: \"Charging Complete / Full Standby\"\n            }[edt[0]] || `Code ${edtHex}`;\n            break;\n        case 0xC1:\n            propertyName = \"Grid Connection Status\";\n            value = {\n                0x00: \"Not Connected\",\n                0x03: \"Enabled / Ready\"\n            }[edt[0]] || `Code ${edtHex}`;\n            break;\n        case 0xC2:\n            propertyName = \"Grid Rated Power Status\";\n            value = {\n                0x01: \"Enabled (Partial)\",\n                0x03: \"Enabled (Full Capacity)\"\n            }[edt[0]] || `Code ${edtHex}`;\n            break;\n        case 0x80:\n            propertyName = \"Operation Status\";\n            value = edt[0] === 0x30 ? \"ON\" : edt[0] === 0x31 ? \"OFF\" : `Code ${edtHex}`;\n            break;\n        case 0x88:\n            propertyName = \"Fault Status\";\n            value = edt[0] === 0x42 ? \"No Fault\" : `Code ${edtHex}`;\n            break;\n        case 0x42:\n            propertyName = \"Unknown EPC 0x42\";\n            value = edtHex;\n            break;\n        case 0x89:\n            propertyName = \"Unknown EPC 0x89\";\n            value = edtHex;\n            break;\n        default:\n            // Leave as default label and raw value\n            break;\n    }\n\n    parsed.push({\n        Timestamp: new Date().toISOString(),\n        EPC: '0x' + epc.toString(16).toUpperCase(),\n        EDT: edtHex,\n        Status: status,\n        Source: sourceAddress,\n        propertyName,\n        value,\n        units\n    });\n\n    offset += (2 + pdc);\n}\n\nreturn { payload: parsed };","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":440,"y":860,"wires":[["b0ed28a7c5ea1aef"]]},{"id":"b0ed28a7c5ea1aef","type":"split","z":"b956abd7fd2a06d1","name":"Split EPCs","splt":"\\n","spltType":"str","arraySplt":1,"stream":false,"addname":"","x":670,"y":860,"wires":[["f269b035cbe910dc","35675e4b2b3d0bd6"]]},{"id":"f269b035cbe910dc","type":"function","z":"b956abd7fd2a06d1","name":"Prepare for Sheet","func":"const p = msg.payload;\n\nmsg.payload = [\n    p.Timestamp,\n    p.EPC,\n    p.propertyName || p.EDT || \"\",\n    p.value || p.Status || \"\",\n    p.units || \"\"\n];\n\nreturn msg;","outputs":1,"noerr":0,"x":870,"y":840,"wires":[["cea83369f876af37"]]},{"id":"35675e4b2b3d0bd6","type":"debug","z":"b956abd7fd2a06d1","name":"EPC after Split","active":false,"tosidebar":true,"console":false,"complete":"true","x":860,"y":880,"wires":[]},{"id":"f549f13b06291919","type":"debug","z":"b956abd7fd2a06d1","d":true,"name":"debug 3","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":600,"y":1840,"wires":[]},{"id":"adacaa9666152310","type":"tapo_new_actions","z":"b956abd7fd2a06d1","d":true,"name":"Battery Status Trigger","deviceIp":"192.168.86.63","deviceAlias":"Cat Bed","deviceIpRange":"192.168.0.0./24","searchMode":"ip","command":"status","version":3,"x":360,"y":1860,"wires":[["f549f13b06291919","f20d5928acc11625"]]},{"id":"386109f2af94eb2d","type":"tapo_new_actions","z":"b956abd7fd2a06d1","d":true,"name":"Battery Status (Off)","deviceIp":"192.168.86.63","deviceAlias":"Cat Bed","deviceIpRange":"192.168.0.0./24","searchMode":"ip","command":"off","version":3,"x":850,"y":1860,"wires":[[]]},{"id":"f20d5928acc11625","type":"function","z":"b956abd7fd2a06d1","d":true,"name":"check status","func":"let current = msg.payload.tapoDeviceInfo.device_on;\nlet previous = context.get(\"lastState\");\n\nlet speakMsg = {\n    payload: {\n        text: \"Hello world!\",\n    }\n};\n\nif (current === true && previous !== true) {\n    context.set(\"lastState\", current);\n    return speakMsg; // Trigger flow when it just turned ON\n} else {\n    context.set(\"lastState\", current);\n    return null; // Suppress if already ON\n}","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":630,"y":1880,"wires":[["a9b854044e93b9c4"]]},{"id":"127a94d7af885137","type":"inject","z":"b956abd7fd2a06d1","d":true,"name":"Poll switch status every 10 seconds","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"10","crontab":"","once":true,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":230,"y":1820,"wires":[["adacaa9666152310"]]},{"id":"a9b854044e93b9c4","type":"alexa-remote-routine","z":"b956abd7fd2a06d1","d":true,"name":"","account":"8c47f57cbd660842","routineNode":{"type":"speak","payload":{"type":"regular","text":{"type":"msg","value":"payload.text"},"devices":["G090XG1213020E50"]}},"x":740,"y":1940,"wires":[["386109f2af94eb2d"]]},{"id":"97ba95035d0da082","type":"function","z":"b956abd7fd2a06d1","d":true,"name":"Analyze and Consolidate Available Energy Data","func":"let baseline = 0.35; // average \"always-on\" load/use, based on observation and Japanese household average\n// low rate energy period: 23:00 - 07:00\n\n// settings from battery system\nconst batterySafetyCharge = 30; // charge kept at all times as an emergency backup\nconst batteryMaximumLowRateCharge= 50; // maximum to which battery charges from the net after 23:00 (if needed) with low rate nighttime energy\n// note that AI in the battery system can override the values and keep a 100% charge at all times in case of bad weather or emergencies.\n\n// --- Retrieve battery & solar ---\nlet solar = flow.get(\"solarData\");\nlet battery = flow.get(\"batteryData\");\nif (!solar || !battery || !battery.properties) return [null];\n\n// --- Extract values ---\nlet gen = solar.soler || 0;\nlet use = solar.use || 0;\nlet buying = solar.buyElec || 0;\nlet selling = solar.selElec || 0;\nlet battery_pct = battery.properties.find(p => p.epc === \"0xE4\")?.value;\nif (battery_pct === undefined) return [null];\n\n// --- Configurable Parameters ---\nconst capacity = 8.8; // Usable battery capacity in kWh (nominal 9.8 kWh)\nconst intervalMinutes = 5;\nconst durationMinutes = flow.get(\"durationMinutes\") || 30;\nconst windowSize = durationMinutes / intervalMinutes;\n\nconst nominalSolarCapacity = 5.04; // in kW, based on installer spec\nif (gen > nominalSolarCapacity) {\n    gen = nominalSolarCapacity; // clamp to expected max\n}\n\nlet solarEfficiency = 0;\nif (nominalSolarCapacity > 0) {\n    solarEfficiency = gen / nominalSolarCapacity;\n}\n\n// --- History Tracking ---\nlet pctHistory = flow.get(\"batteryPctHistory\") || [];\npctHistory.push(battery_pct);\nif (pctHistory.length > windowSize) pctHistory.shift();\nflow.set(\"batteryPctHistory\", pctHistory);\n\n// --- Delta Calculation ---\nlet delta = 0;\nif (pctHistory.length === windowSize) {\n    delta = battery_pct - pctHistory[0];\n}\nlet rate_kWh = (delta / 100) * capacity;\nlet rate_kW = rate_kWh / durationMinutes;\nconst maxBatteryRate = 4.0; // max charge/discharge throughput (kW)\nrate_kW = Math.max(Math.min(rate_kW, maxBatteryRate), -maxBatteryRate);\n\n// --- Status Logic ---\nlet status = \"idle\";\nif (battery_pct > 30) {\n    if (buying === 0 && gen < use) status = \"discharging\";\n    if (buying > 0 && gen < use) status = \"idle\";\n    if (gen >= use && battery_pct > pctHistory[0]) status = \"charging\";\n}\nif (rate_kW < 0) status = \"discharging\";\nif (rate_kW === 0) status = \"idle\";\nif (rate_kW > 0) status = \"charging\";\n\nconst minSafePct = 10;\nif (battery_pct < minSafePct) status = \"idle\"; // prevent misleading discharge classification\n\n\n// --- Household Calculation ---\nlet adjustedUse = use; // default: use equals household consumption\n\nif (status === \"charging\" && buying > 0) {\n    // Estimate battery charging from grid based on rate and buying\n    let batteryGridCharge = Math.min(rate_kW, buying);\n    adjustedUse = use - batteryGridCharge;\n}\n\nlet household = parseFloat(adjustedUse.toFixed(2)); // use - Math.max(gen - use, 0);\n\nlet chargingSource = \"unknown\";\nif (status === \"charging\") {\n    if (gen > use) chargingSource = \"solar\";\n    else if (buying > 0) chargingSource = \"grid\";\n}\nif (status === \"charging\") {\n    if (gen > use + rate_kW) chargingSource = \"solar-surplus\";\n    else if (buying >= rate_kW) chargingSource = \"grid\";\n}\n\n// --- Weather ---\nlet weather = flow.get(\"weatherData\");\nlet sunData = flow.get(\"sunData\");\n\n// --- Timestamp ---\nlet timestamp = new Date().toLocaleTimeString(\"ja-JP\", {\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n    hour12: false,\n    timeZone: \"Asia/Tokyo\"\n});\n\n// --- Final Output ---\nmsg.payload = {\n    timestamp,\n    sundata: {\n        sunrise: sunData.sunrise, \n        sunset: sunData.sunset\n    },    \n    solar: {\n        generation_kW: gen,\n        usage_kW: use,\n        buy_kW: buying,\n        sell_kW: selling,\n        efficiency: parseFloat(solarEfficiency.toFixed(3))\n    },\n    battery: {\n        percent: battery_pct,\n        status: status,\n        rate_kW: parseFloat(rate_kW.toFixed(2)),\n        source: chargingSource\n    },\n    calculation: {\n        household_kW: parseFloat(household.toFixed(2)),\n        delta_pct: pctHistory.length === windowSize ? delta : null,\n        durationMinutes,\n        capacity_kWh: capacity\n    },\n    weather\n};\n\nglobal.set(\"energyData\", msg.payload);\n\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":500,"y":40,"wires":[[]]},{"id":"bba524eeeb008f07","type":"ui-group","name":"Group 1","page":"ab5ec8f96a52254b","width":6,"height":1,"order":1,"showTitle":false,"className":"","visible":"true","disabled":"false","groupType":"default"},{"id":"166c30c33417c9d1","type":"gauth","name":"node-red-logger@basic-formula-465104-i9.iam.gserviceaccount.com"},{"id":"8c47f57cbd660842","type":"alexa-remote-account","name":"","authMethod":"proxy","proxyOwnIp":"192.168.86.220","proxyPort":3456,"cookieFile":"/data/alexa-auth.json","refreshInterval":"3","alexaServiceHost":"pitangui.amazon.com","pushDispatchHost":"","amazonPage":"amazon.com","acceptLanguage":"en-US","onKeywordInLanguage":"on","userAgent":"","usePushConnection":"on","autoInit":"on","autoQueryActivityOnTrigger":"off"},{"id":"ab5ec8f96a52254b","type":"ui-page","name":"Battery","ui":"df3d6cd6608fc3c3","path":"/battery","icon":"battery","layout":"grid","theme":"5b3b4b3109bc086d","breakpoints":[{"name":"Default","px":"0","cols":"3"},{"name":"Tablet","px":"576","cols":"6"},{"name":"Small Desktop","px":"768","cols":"9"},{"name":"Desktop","px":"1024","cols":"12"}],"order":1,"className":"","visible":true,"disabled":false},{"id":"df3d6cd6608fc3c3","type":"ui-base","name":"My Dashboard","path":"/dashboard","appIcon":"http://192.168.86.220:8081/home_automation_home.png","includeClientData":true,"acceptsClientConfig":["ui-notification","ui-control","ui-chart","ui-gauge","ui-state-timeline","ui-text"],"showPathInSidebar":false,"headerContent":"page","navigationStyle":"default","titleBarStyle":"default","showReconnectNotification":true,"notificationDisplayTime":1,"showDisconnectNotification":true,"allowInstall":true},{"id":"5b3b4b3109bc086d","type":"ui-theme","name":"Default Theme","colors":{"surface":"#ffffff","primary":"#0094CE","bgPage":"#eeeeee","groupBg":"#ffffff","groupOutline":"#cccccc"},"sizes":{"density":"default","pagePadding":"12px","groupGap":"12px","groupBorderRadius":"4px","widgetGap":"12px"}}]